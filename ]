mod convertor;
mod corrector;
mod naming_principal;
mod reserved_store;

use crate::{convertor::NamingPrincipalConvertor, reserved_store::PascalCaseReservedIdentifiers};

pub struct Parameter {
    source: String,
}

pub fn to_camel(source: &str) -> String {
    NamingPrincipalConvertor::new(source).to_camel()
}
pub fn to_pascal(source: &str) -> String {
    NamingPrincipalConvertor::new(source).to_pascal()
}
pub fn to_snake(source: &str) -> String {
    NamingPrincipalConvertor::new(source).to_snake()
}
pub fn to_constant(source: &str) -> String {
    NamingPrincipalConvertor::new(source).to_constant()
}
pub fn to_chain(source: &str) -> String {
    NamingPrincipalConvertor::new(source).to_chain()
}

pub trait Convert {
    fn convert(&self, source: &str) -> String;
}
impl<F> Convert for F
where
    F: Fn(&str) -> String,
{
    fn convert(&self, source: &str) -> String {
        self(source)
    }
}

pub fn to_camel_with_pre_convert<T: Convert>(source: &str, convert: T) -> String {
    to_camel(&convert.convert(source))
}
pub fn to_pascal_with_pre_convert<T: Convert>(source: &str, convert: T) -> String {
    to_pascal(&convert.convert(source))
}
pub fn to_snake_with_pre_convert<T: Convert>(source: &str, convert: T) -> String {
    to_snake(&convert.convert(source))
}
pub fn to_constant_with_pre_convert<T: Convert>(source: &str, convert: T) -> String {
    to_constant(&convert.convert(source))
}
pub fn to_chain_with_pre_convert<T: Convert>(source: &str, convert: T) -> String {
    to_chain(&convert.convert(source))
}

pub fn to_snake_consider_with_wellknown_word(source: &str) -> String {
    let snake = to_snake(source);
    PascalCaseReservedIdentifiers::wellknown().replace_for_snake_case(snake)
}
pub fn to_snake_consider_with_words(source: &str, words: &[&str]) -> String {
    let mut reserved_store = PascalCaseReservedIdentifiers::new();
    words.into_iter().for_each(|s| reserved_store.add(*s));
    let snake = to_snake(source);
    reserved_store.replace_for_snake_case(snake)
}
pub fn to_snake_consider_with_wellknown_and_others(source: &str, words: &[&str]) -> String {
    let mut reserved_store = PascalCaseReservedIdentifiers::wellknown();
    words.into_iter().for_each(|s| reserved_store.add(*s));
    let snake = to_snake(source);
    reserved_store.replace_for_snake_case(snake)
}
pub fn to_constant_consider_with_wellknown_word(source: &str) -> String {
    let constant = to_constant(source);
    PascalCaseReservedIdentifiers::wellknown().replace_for_constant_case(constant)
}
pub fn to_constant_with_words(source: &str, words: &[&str]) -> String {
    let mut reserved_store = PascalCaseReservedIdentifiers::new();
    words.into_iter().for_each(|s| reserved_store.add(*s));
    let constant = to_constant(source);
    reserved_store.replace_for_constant_case(constant)
}
pub fn to_constant_consider_with_wellknown_and_others(source: &str, words: &[&str]) -> String {
    let mut reserved_store = PascalCaseReservedIdentifiers::wellknown();
    words.into_iter().for_each(|s| reserved_store.add(*s));
    let constant = to_constant(source);
    reserved_store.replace_for_constant_case(constant)
}
pub fn to_chain_consider_with_wellknown_word(source: &str) -> String {
    let chain = to_chain(source);
    PascalCaseReservedIdentifiers::wellknown().replace_for_chain_case(chain)
}
pub fn to_chain_consider_with_words(source: &str, words: &[&str]) -> String {
    let mut reserved_store = PascalCaseReservedIdentifiers::new();
    words.into_iter().for_each(|s| reserved_store.add(*s));
    let chain = to_chain(source);
    reserved_store.replace_for_chain_case(chain)
}
pub fn to_chain_consider_with_wellknown_word_and_others(source: &str, words: &[&str]) -> String {
    let mut reserved_store = PascalCaseReservedIdentifiers::wellknown();
    words.into_iter().for_each(|s| reserved_store.add(*s));
    let chain = to_chain(source);
    reserved_store.replace_for_chain_case(chain)
}
pub fn to_pascal_consider_with_wellknown_word_and_others(source: &str, words: &[&str]) -> String {
    let mut reserved_store = PascalCaseReservedIdentifiers::wellknown();
    words.into_iter().for_each(|s| reserved_store.add(*s));
    let pascal = to_pascal(source);
    reserved_store.replace_for_pascal_case(pascal)
}
pub fn to_pascal_consider_with_words(source: &str, words: &[&str]) -> String {
    let mut reserved_store = PascalCaseReservedIdentifiers::new();
    words.into_iter().for_each(|s| reserved_store.add(*s));
    let pascal = to_pascal(source);
    reserved_store.replace_for_pascal_case(pascal)
}
pub fn to_pascal_consider_with_wellknown_word(source: &str) -> String {
    let pascal = to_pascal(source);
    PascalCaseReservedIdentifiers::wellknown().replace_for_pascal_case(pascal)
}

#[cfg(test)]
mod tests {
    use super::*;

    use super::to_pascal;

    #[test]
    fn consider_reserved_words_in_pascal_case_names() {
        let source = "UKaiUseGitHubEnterpriseGitHub";
        let words = vec!["UKai"];

        let result = to_snake_consider_with_wellknown_and_others(source, &words);
        assert_eq!(result, "ukai_use_github_enterprise_github");
        let result = to_constant_consider_with_wellknown_and_others(source, &words);
        assert_eq!(result, "UKAI_USE_GITHUB_ENTERPRISE_GITHUB");
        let result = to_chain_consider_with_wellknown_word_and_others(source, &words);
        assert_eq!(result, "ukai-use-github-enterprise-github");

        let source = "ukai-use-github-enterprise-github";
        let words = vec!["UKai"];
        assert_eq!(
            to_pascal_consider_with_wellknown_word_and_others(source, &words),
            "UKaiUseGitHubEnterpriseGitHub"
        );
    }
    #[test]
    fn consider_registered_names_in_pascal_case() {
        let source = "UKaiUseGitHubEnterpriseGitHub";
        let words = vec!["UKai"];

        let result = to_snake_consider_with_words(source, &words);
        assert_eq!(result, "ukai_use_git_hub_enterprise_git_hub");
        let result = to_constant_with_words(source, &words);
        assert_eq!(result, "UKAI_USE_GIT_HUB_ENTERPRISE_GIT_HUB");
        let result = to_chain_consider_with_words(source, &words);
        assert_eq!(result, "ukai-use-git-hub-enterprise-git-hub");
    }
    #[test]
    fn consider_pascal_case_names_with_registered_words() {
        let source = "UseGitHubEnterpriseGitHub";

        let result = to_snake_consider_with_wellknown_word(source);
        assert_eq!(result, "use_github_enterprise_github");
        let result = to_constant_consider_with_wellknown_word(source);
        assert_eq!(result, "USE_GITHUB_ENTERPRISE_GITHUB");
        let result = to_chain_consider_with_wellknown_word(source);
        assert_eq!(result, "use-github-enterprise-github");
    }
    #[test]
    fn convert_to_pascal_case_considering_registered_names() {
        let source = "github_user";
        let result = to_pascal_consider_with_wellknown_word(source);
        assert_eq!(result, "GitHubUser");
        let source = "github-user";
        let result = to_pascal_consider_with_wellknown_word(source);
        assert_eq!(result, "GitHubUser");
        let source = "githubUser";
        let result = to_pascal_consider_with_wellknown_word(source);
        assert_eq!(result, "GitHubUser");
    }
    #[test]
    fn investigate_cases_that_did_not_work() {
        let sut = "get_edge_configuration_stack_with_edge_id9012";
        assert_eq!(to_pascal(sut), "GetEdgeConfigurationStackWithEdgeId9012");
    }
}
